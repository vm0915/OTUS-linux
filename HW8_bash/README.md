# Bash

Задание заключалось в написании скрипта, который анализирует лог и раз в период времени присылает указанное количество ip-адресов с наибольшим количеством запросов (X) и указанное количество наиболее запрашиваемых адресов (Y) с момента последнего запуска скрипта. А также все ошибки с момента последнего запуска и список всех кодов возврата с указанием их количества.

## 1. Имитация растущего лога
В качестве исходного лога был использован файл [access-4560-644067.log](access-4560-644067.log) предоставленный преподавателем.
Чтобы имитировать рост лога для проверок, был написан скрипт [loggrow.sh](loggrow.sh), который раз в *50 секунд* стравливает по 50 строк в другой файл (part.log) который и будет анализироваться.

## 2. Главный скрипт
Основную работу выполняет скрипт (parser.sh)[parser.sh].
Он имеет подробные комментарии, здесь расмотрим ключевые моменты.

В начале скрипта идет объявление переменных. Здесь отмечу конструкцию подстановки значений по умолчанию, если скрипт запущен без параметров (количество выводимых ip и URI по заданию)
```bash
DEFAULTX=5
DEFAULTY=5
X=${1:-$DEFAULTX}
Y=${2:-$DEFAULTY}
```

Рабочей директорией для побочных файлов скрипта выбрана **/var/lib/parser/**
Здесь будут хранитья файлы:
**/var/lib/parser/last.timestamp** - здесь будет сохранятся временная отметка последней записи в логе в момент последнего запуска скрипта. Для сделано для универсальности, на случай если файл будет обрезан и номер строки будет не репрезентативен.
**/var/lib/parser/mail.text** - здесь будет формироваться письмо с результатами анализа для отправки

Чтобы избежать запуска дублирующего процесса используется файл **/run/parser.pid**. При запуске скрипт пытается записать в этот файл свой PID, и, если он уже существует, параметр *noclobber* не дает перезаписать, в результате чего возвращается код ошибки и скрипт завершает работу.
```bash
if (set -o noclobber; echo "$$" > "$LOCKFILE") &> /dev/null
then
...
fi
```

Для того чтобы при преждевременном завершении процесса lockfile был удален, ставиться **trap**, который перехватывает указанные сигналы от системы и удаляет **/run/parser.pid**
```bash
cleaning(){
rm -f "$LOCKFILE"; exit $?
}

trap 'cleaning' INT TERM EXIT
```

### Алгоритм анализатора
Из файла **/var/lib/parser/last.timestamp** узнаем временую отметку последней записи в логе при прошлом запуске скрипта, если ее нет то анализируем весь лог, иначе копируем начиная с нее и до конца основого лога в отдельный файл **part.log** 
```bash
if [ ! -z "$LASTTIMESTAMP" ]
  then
  # найти строчку с этим временем в файле и скопировать записи с этого момента в отдельный файл
  LINE=$(grep --line-number -F "$LASTTIMESTAMP" $LOGFILE | cut --fields 1 --delimiter ":" | head -1 )
else
  LINE=0
fi

COUNT=$(cat $LOGFILE | wc -l )
cat $LOGFILE | tail -n $(($COUNT-$LINE)) > $PARTLOG
```
Если **part.log** пустой, то выводим информационное сообщение и завершаем работу.
```bash
if [ ! -s "$PARTLOG" ]
then
echo "Нет новых записей в логе с последнего анализа"
cleaning
fi
```
Здесь стоит отметить алиас команды `test` являющийся `[ ]`.
`!` означает инверсию
`-z` - не пустая строка
`-s` - не пустой файл
Квадратные скобки обязательно отделять пробелами.

Далее идентичными конвейерами команд находится нужная информация и заполяется файл письма **/var/lib/parser/mail.text**.
Разберем одну из них:
```bash
echo "IP адреса с наибольшим количеством запросов:" >> $MAILTEXT
cat $PARTLOG | cut --fields 1 --delimiter " " | sort | uniq -c | sort -k1 -n -r | head -$X >> $MAILTEXT
```
Команда `cut  --fields 1 --delimiter " "` - отобразить первый столбец, разделить столбцов "пробел"
`sort` - сортировка
`uniq -c` - удалить соседние дубликаты, перед каждой строкой выводить количество вхождений
`sort -k1 -n -r` - k1 ключ сртировки, -n числовая сортировка, -r в обратном порядке
`head -n` - оставить n первых строк

Затем отправляем письмо пользователю vagrant
```bash
mail -s "Log analysis" vagrant < $MAILTEXT
```

## 3. Периодичность выполнения
Так как cron уже устарел, для периодического запуска задания были использваны механизмы *systemd*.
Был создан юнит [parser.service](parser.service) в котором можно указать количество адресов в письме.
```bash
[Unit]
Description="Log analysis"

[Service]
Type=simple
ExecStart=/bin/bash /vagrant/parser.sh 4 3
```

Для повторяющегося запуска был создан [parser.timer](parser.timer), который стартует от запуска [parser.service](parser.service) и запускает его снова каждые *30 секунд*.
```bash
[Unit]
Description="Analyze log every 30 seconds"

[Timer]
OnUnitActiveSec=30
AccuracySec=1us

[Install]
WantedBy=parser.service
```

## 4. Запуск
[Vagrantfile](Vagrantfile) создает виртуальную машину, копирует в нее файлы с помощью rsync и провижинет ей [script.sh](script.sh), который:
- устанавливает необходимые права на файлы
- ставит бит разрешения исполнения
- размещает файлы по нужным директориям
- устанавливает mailx
- запускает скрипт для имитации растущего лога
- включает демон и таймер анализатора лога
- старутет демона


