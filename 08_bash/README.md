# Bash
**Домашнее задание:**
```
Пишем скрипт
написать скрипт для крона
который раз в час присылает на заданную почту
- X IP адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта
- Y запрашиваемых адресов (с наибольшим кол-вом запросов) с указанием кол-ва запросов c момента последнего запуска скрипта
- все ошибки c момента последнего запуска
- список всех кодов возврата с указанием их кол-ва с момента последнего запуска
в письме должно быть прописан обрабатываемый временной диапазон
должна быть реализована защита от мультизапуска
Критерии оценки:
трапы и функции, а также sed и find +1 балл
```

**Ход выполнения:**

Задание заключалось в написании скрипта, который анализирует лог и раз в период времени присылает указанное количество ip-адресов с наибольшим количеством запросов (X) и указанное количество наиболее запрашиваемых адресов (Y) с момента последнего запуска скрипта. А также все ошибки с момента последнего запуска и список всех кодов возврата с указанием их количества.

## 1. Имитация растущего лога
В качестве исходного лога был использован файл [access-4560-644067.log](access-4560-644067.log) предоставленный преподавателем.
Чтобы имитировать рост лога для проверок, был написан скрипт [loggrow.sh](loggrow.sh), который раз в *50 секунд* стравливает по 50 строк в другой файл (part.log) который и будет анализироваться.

## 2. Главный скрипт
Основную работу выполняет скрипт [parser.sh](parser.sh).
Он имеет подробные комментарии, здесь рассмотрим ключевые моменты.

В начале скрипта идет объявление переменных. Здесь отмечу конструкцию подстановки значений по умолчанию, если скрипт запущен без параметров (количество выводимых ip и URI по заданию)
```bash
DEFAULTX=5
DEFAULTY=5
X=${1:-$DEFAULTX}
Y=${2:-$DEFAULTY}
```

Рабочей директорией для побочных файлов скрипта выбрана **/var/lib/parser/**
Здесь будут хранитья файлы:
**/var/lib/parser/last.timestamp** - здесь будет сохранятся временная отметка последней записи в логе в момент последнего запуска скрипта. Для сделано для универсальности, на случай если файл будет обрезан и номер строки будет не репрезентативен.
**/var/lib/parser/mail.text** - здесь будет формироваться письмо с результатами анализа для отправки

Чтобы избежать запуска дублирующего процесса используется файл **/run/parser.pid**. При запуске скрипт пытается записать в этот файл свой PID, и, если он уже существует, параметр *noclobber* не дает перезаписать, в результате чего возвращается код ошибки и скрипт завершает работу.
```bash
if (set -o noclobber; echo "$$" > "$LOCKFILE") &> /dev/null
then
...
fi
```

Для того чтобы при преждевременном завершении процесса lockfile был удален, ставиться **trap**, который перехватывает указанные сигналы от системы и удаляет **/run/parser.pid**
```bash
cleaning(){
rm -f "$LOCKFILE"; exit $?
}

trap 'cleaning' INT TERM EXIT
```

### Алгоритм анализатора
Из файла **/var/lib/parser/last.timestamp** узнаем временую отметку последней записи в логе при прошлом запуске скрипта, если ее нет то анализируем весь лог, иначе копируем начиная с нее и до конца основого лога в отдельный файл **part.log** 
```bash
if [ ! -z "$LASTTIMESTAMP" ]
  then
  # найти строчку с этим временем в файле и скопировать записи с этого момента в отдельный файл
  LINE=$(grep --line-number -F "$LASTTIMESTAMP" $LOGFILE | cut --fields 1 --delimiter ":" | head -1 )
else
  LINE=0
fi

COUNT=$(cat $LOGFILE | wc -l )
cat $LOGFILE | tail -n $(($COUNT-$LINE)) > $PARTLOG
```
Если **part.log** пустой, то выводим информационное сообщение и завершаем работу.
```bash
if [ ! -s "$PARTLOG" ]
then
echo "Нет новых записей в логе с последнего анализа"
cleaning
fi
```
Здесь стоит отметить алиас команды `test` являющийся `[ ]`.

`!` означает инверсию

`-z` - не пустая строка

`-s` - не пустой файл

Квадратные скобки обязательно отделять пробелами.

Далее идентичными конвейерами команд находится нужная информация и заполяется файл письма **/var/lib/parser/mail.text**.
Разберем одну из них:
```bash
echo "IP адреса с наибольшим количеством запросов:" >> $MAILTEXT
cat $PARTLOG | cut --fields 1 --delimiter " " | sort | uniq -c | sort -k1 -n -r | head -$X >> $MAILTEXT
```
Команда `cut  --fields 1 --delimiter " "` - отобразить первый столбец, разделить столбцов "пробел"

`sort` - сортировка

`uniq -c` - удалить соседние дубликаты, перед каждой строкой выводить количество вхождений

`sort -k1 -n -r` - k1 ключ сртировки, -n числовая сортировка, -r в обратном порядке

`head -n` - оставить n первых строк

Затем отправляем письмо пользователю vagrant
```bash
mail -s "Log analysis" vagrant < $MAILTEXT
```

## 3. Периодичность выполнения
Так как cron уже устарел, для периодического запуска задания были использваны механизмы *systemd*.
Был создан юнит [parser.service](parser.service) в котором можно указать количество адресов в письме.
```bash
[Unit]
Description="Log analysis"

[Service]
Type=simple
ExecStart=/bin/bash /vagrant/parser.sh 4 3
```

Для повторяющегося запуска был создан [parser.timer](parser.timer), который стартует от запуска [parser.service](parser.service) и запускает его снова каждые *30 секунд*.
```bash
[Unit]
Description="Analyze log every 30 seconds"

[Timer]
OnUnitActiveSec=30
AccuracySec=1us

[Install]
WantedBy=parser.service
```

## 4. Запуск
[Vagrantfile](Vagrantfile) создает виртуальную машину, копирует в нее файлы с помощью rsync и провижинет ей [script.sh](script.sh), который:
- устанавливает необходимые права на файлы
- ставит бит разрешения исполнения
- размещает файлы по нужным директориям
- устанавливает mailx
- запускает скрипт для имитации растущего лога
- включает демон и таймер анализатора лога
- старутет демона

## 5. Пример письма
В результате работы демона на почту пользователю vagrant приходит письмо вида:
```bash
From root@bashvm.localdomain  Wed Sep  2 10:11:36 2020
Return-Path: <root@bashvm.localdomain>
X-Original-To: vagrant
Delivered-To: vagrant@bashvm.localdomain
Received: by localhost.localdomain (Postfix, from userid 0)
        id 8700D400A4C4; Wed,  2 Sep 2020 10:11:36 +0000 (UTC)
Date: Wed, 02 Sep 2020 10:11:36 +0000
To: vagrant@bashvm.localdomain
Subject: Log analysis
User-Agent: Heirloom mailx 12.5 7/5/10
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit
Message-Id: <20200902101136.8700D400A4C4@bashvm.localdomain>
From: root@bashvm.localdomain (root)

Временной диапазон:
14/Aug/2019:21:00:01 +0300 --- 14/Aug/2019:23:31:58 +0300
IP адреса с наибольшим количеством запросов:
      8 93.158.167.130
      3 89.32.248.234
      3 87.250.233.68
      3 86.109.170.96
Наиболее запрашиваемые URI:
     17 /
     15 /wp-login.php
      7 /xmlrpc.php
Возвращенные коды ошибок:
400
404
500
Все коды ответов:
     39 200
      5 301
      4 404
      1 500
      1 400



